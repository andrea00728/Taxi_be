import { Request, Response } from "express";
import { ArretService } from "../services/arret.service.js";
import { LigneService } from "../services/ligne.service.js";

const arretSvc = new ArretService();
const ligneSvc = new LigneService();

interface ArretWithDistance {
  arret: any;
  distance: number;
}

interface RouteOption {
  type: "direct" | "with_transfer";
  lignes: any[];
  arrets: any[];
  transferCount: number;
  estimatedDistance: number;
  totalDistance: number;
  score: number;
  instructions: string[];
  walkingDistance?: number;
}

export class TrajetController {
  /**
   * Calcule la distance entre deux points GPS avec la formule de Haversine
   */
  private static calculateDistance(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number
  ): number {
    const R = 6371e3;
    const œÜ1 = (lat1 * Math.PI) / 180;
    const œÜ2 = (lat2 * Math.PI) / 180;
    const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
    const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;

    const a =
      Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
      Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
  }

  private static findNearestArret(
    targetLat: number,
    targetLon: number,
    arrets: any[]
  ): ArretWithDistance | null {
    if (!arrets || arrets.length === 0) return null;

    let nearest: ArretWithDistance | null = null;
    let minDistance = Infinity;

    for (const arret of arrets) {
      const lat = parseFloat(arret.latitude);
      const lon = parseFloat(arret.longitude);

      if (isNaN(lat) || isNaN(lon)) continue;

      const distance = this.calculateDistance(targetLat, targetLon, lat, lon);

      if (distance < minDistance) {
        minDistance = distance;
        nearest = { arret, distance };
      }
    }

    return nearest;
  }

  static async search(req: Request, res: Response) {
    const depart = (req.query.depart as string)?.trim() || "";
    const destination = (req.query.destination as string)?.trim() || "";
    const maxTransfers = parseInt(req.query.maxTransfers as string) || 2;
    const maxWalkingDistance = parseInt(req.query.maxWalkingDistance as string) || 500;
    const limit = parseInt(req.query.limit as string) || 5;

    console.log("\n" + "=".repeat(60));
    console.log("üîç RECHERCHE DE TRAJET");
    console.log("=".repeat(60));
    console.log(`üìç D√©part: "${depart}"`);
    console.log(`üéØ Destination: "${destination}"`);
    console.log(`‚öôÔ∏è  Filtres: maxTransfers=${maxTransfers}, maxWalkingDistance=${maxWalkingDistance}m`);

    if (!depart || !destination) {
      return res.status(400).json({
        message: "D√©part et destination requis",
        error: "MISSING_PARAMETERS",
      });
    }

    // 1. Recherche des arr√™ts de d√©part et destination
    console.log("\nüìç √âTAPE 1: Recherche des arr√™ts");
    const departArrets = await arretSvc.findByName(depart);
    const destArrets = await arretSvc.findByName(destination);

    console.log(`  ‚úÖ Arr√™ts de d√©part trouv√©s: ${departArrets.length}`);
    if (departArrets.length > 0) {
      departArrets.forEach((a: any) => {
        console.log(`     - ${a.nom} (ID: ${a.id}, Ligne: ${a.ligne?.nom || "N/A"})`);
      });
    }

    console.log(`  ‚úÖ Arr√™ts de destination trouv√©s: ${destArrets.length}`);
    if (destArrets.length > 0) {
      destArrets.forEach((a: any) => {
        console.log(`     - ${a.nom} (ID: ${a.id}, Ligne: ${a.ligne?.nom || "N/A"})`);
      });
    }

    if (departArrets.length === 0) {
      return res.status(404).json({
        message: `Aucun arr√™t trouv√© pour le d√©part: "${depart}"`,
        error: "DEPARTURE_NOT_FOUND",
        suggestions: await TrajetController.getSuggestions(depart, arretSvc),
      });
    }

    if (destArrets.length === 0) {
      return res.status(404).json({
        message: `Aucun arr√™t trouv√© pour la destination: "${destination}"`,
        error: "DESTINATION_NOT_FOUND",
        suggestions: await TrajetController.getSuggestions(destination, arretSvc),
      });
    }

    // 2. R√©cup√©rer toutes les lignes avec leurs arr√™ts
    console.log("\nüöå √âTAPE 2: Chargement des lignes accept√©es");
    const allLignes = await ligneSvc.findAllWithArrets();
    const acceptedLignes = allLignes.filter((l: any) => 
      l.statut === "Accepted" && l.arrets && l.arrets.length > 0
    );

    console.log(`  ‚úÖ Total lignes accept√©es avec arr√™ts: ${acceptedLignes.length}`);
    acceptedLignes.forEach((l: any) => {
      console.log(`     - ${l.nom}: ${l.arrets.length} arr√™t(s)`);
    });

    const routes: RouteOption[] = [];

    // 3. Routes directes
    console.log("\nüéØ √âTAPE 3: Recherche de routes directes");
    const directRoutes = await TrajetController.findDirectRoutes(
      departArrets,
      destArrets
    );
    console.log(`  ‚úÖ Routes directes trouv√©es: ${directRoutes.length}`);
    routes.push(...directRoutes);

    // 4. Routes avec correspondances
    if (maxTransfers > 0) {
      console.log("\nüîÑ √âTAPE 4: Recherche de routes avec correspondances");
      const transferRoutes = await TrajetController.findIntelligentTransferRoutes(
        departArrets,
        destArrets,
        acceptedLignes,
        maxWalkingDistance,
        maxTransfers
      );
      console.log(`  ‚úÖ Routes avec correspondances trouv√©es: ${transferRoutes.length}`);
      routes.push(...transferRoutes);
    }

    // 5. Tri et limite
    routes.sort((a, b) => b.score - a.score);
    const topRoutes = routes.slice(0, limit);

    console.log("\nüìä R√âSUM√â FINAL");
    console.log(`  Total routes trouv√©es: ${routes.length}`);
    console.log(`  Routes retourn√©es: ${topRoutes.length}`);
    console.log("=".repeat(60) + "\n");

    if (topRoutes.length === 0) {
      return res.status(404).json({
        message: "Aucun trajet trouv√©",
        error: "NO_ROUTE_FOUND",
        depart: {
          query: depart,
          arrets: departArrets.map((a: any) => ({ 
            id: a.id, 
            nom: a.nom,
            ligne: a.ligne?.nom || null
          })),
        },
        destination: {
          query: destination,
          arrets: destArrets.map((a: any) => ({ 
            id: a.id, 
            nom: a.nom,
            ligne: a.ligne?.nom || null
          })),
        },
        suggestion:
          "Essayez d'augmenter la distance de marche maximale ou le nombre de correspondances",
        debug: {
          acceptedLignesCount: acceptedLignes.length,
          departArretsCount: departArrets.length,
          destArretsCount: destArrets.length,
          departLignes: departArrets.map((a: any) => a.ligne?.nom).filter(Boolean),
          destLignes: destArrets.map((a: any) => a.ligne?.nom).filter(Boolean),
        },
      });
    }

    res.json({
      depart: {
        query: depart,
        arrets: departArrets.map((a: any) => ({
          id: a.id,
          nom: a.nom,
          latitude: a.latitude,
          longitude: a.longitude,
        })),
      },
      destination: {
        query: destination,
        arrets: destArrets.map((a: any) => ({
          id: a.id,
          nom: a.nom,
          latitude: a.latitude,
          longitude: a.longitude,
        })),
      },
      routes: topRoutes,
      totalFound: routes.length,
      filters: {
        maxTransfers,
        maxWalkingDistance: `${maxWalkingDistance}m`,
        limit,
      },
    });
  }

  private static async findDirectRoutes(
    departArrets: any[],
    destArrets: any[]
  ): Promise<RouteOption[]> {
    const routes: RouteOption[] = [];
    const processedLignes = new Set<number>();

    for (const depArret of departArrets) {
      if (!depArret.ligne) {
        console.log(`    ‚ö†Ô∏è  "${depArret.nom}" n'a pas de ligne associ√©e`);
        continue;
      }

      for (const destArret of destArrets) {
        if (!destArret.ligne) {
          console.log(`    ‚ö†Ô∏è  "${destArret.nom}" n'a pas de ligne associ√©e`);
          continue;
        }

        if (depArret.ligne.id === destArret.ligne.id) {
          const ligneId = depArret.ligne.id;

          if (processedLignes.has(ligneId)) continue;
          processedLignes.add(ligneId);

          const distance = this.calculateDistance(
            parseFloat(depArret.latitude),
            parseFloat(depArret.longitude),
            parseFloat(destArret.latitude),
            parseFloat(destArret.longitude)
          );

          console.log(`    ‚úÖ Route directe via ${depArret.ligne.nom}: ${Math.round(distance)}m`);

          routes.push({
            type: "direct",
            lignes: [depArret.ligne],
            arrets: [depArret, destArret],
            transferCount: 0,
            estimatedDistance: distance,
            totalDistance: distance,
            score: 100 - distance / 1000,
            instructions: [
              `Prendre ${depArret.ligne.nom} √† "${depArret.nom}"`,
              `Descendre √† "${destArret.nom}"`,
              `Distance estim√©e: ${Math.round(distance)}m`,
            ],
          });
        }
      }
    }

    return routes;
  }

  private static async findIntelligentTransferRoutes(
    departArrets: any[],
    destArrets: any[],
    allLignes: any[],
    maxWalkingDistance: number,
    maxTransfers: number
  ): Promise<RouteOption[]> {
    const routes: RouteOption[] = [];

    for (const depArret of departArrets) {
      if (!depArret.ligne) {
        console.log(`    ‚ö†Ô∏è  Arr√™t de d√©part "${depArret.nom}" sans ligne`);
        continue;
      }

      const ligneDepart = depArret.ligne;
      console.log(`\n    üöå Analyse de ${ligneDepart.nom}`);

      // Trouver la ligne compl√®te avec tous ses arr√™ts
      const ligneCompletDepart = allLignes.find((l: any) => l.id === ligneDepart.id);
      
      if (!ligneCompletDepart || !ligneCompletDepart.arrets || ligneCompletDepart.arrets.length === 0) {
        console.log(`       ‚ùå ${ligneDepart.nom} n'a pas d'arr√™ts charg√©s`);
        continue;
      }

      const arretsLigneDepart = ligneCompletDepart.arrets;
      console.log(`       ‚Üí ${arretsLigneDepart.length} arr√™ts disponibles`);

      for (const destArret of destArrets) {
        const destLat = parseFloat(destArret.latitude);
        const destLon = parseFloat(destArret.longitude);

        if (isNaN(destLat) || isNaN(destLon)) continue;

        let bestTransfer: {
          arretDescente: any;
          ligneCorrespondance: any;
          arretMontee: any;
          arretDestination: any;
          walkDistance: number;
          totalDistance: number;
        } | null = null;

        // Parcourir tous les arr√™ts de la ligne de d√©part
        for (const arretDescente of arretsLigneDepart) {
          const descenteLat = parseFloat(arretDescente.latitude);
          const descenteLon = parseFloat(arretDescente.longitude);

          if (isNaN(descenteLat) || isNaN(descenteLon)) continue;

          // Chercher une correspondance sur les autres lignes
          for (const autreLigne of allLignes) {
            if (autreLigne.id === ligneDepart.id) continue;
            if (!autreLigne.arrets || autreLigne.arrets.length === 0) continue;

            // Trouver l'arr√™t le plus proche sur cette autre ligne
            const nearestArret = this.findNearestArret(
              descenteLat,
              descenteLon,
              autreLigne.arrets
            );

            if (!nearestArret || nearestArret.distance > maxWalkingDistance) continue;

            // V√©rifier si cette ligne va vers la destination
            const nearestToDest = this.findNearestArret(
              destLat,
              destLon,
              autreLigne.arrets
            );

            if (!nearestToDest) continue;

            // Calcul des distances
            const distanceDepart = this.calculateDistance(
              parseFloat(depArret.latitude),
              parseFloat(depArret.longitude),
              descenteLat,
              descenteLon
            );

            const distanceTransfer = this.calculateDistance(
              parseFloat(nearestArret.arret.latitude),
              parseFloat(nearestArret.arret.longitude),
              parseFloat(nearestToDest.arret.latitude),
              parseFloat(nearestToDest.arret.longitude)
            );

            const walkToDestination = this.calculateDistance(
              parseFloat(nearestToDest.arret.latitude),
              parseFloat(nearestToDest.arret.longitude),
              destLat,
              destLon
            );

            const totalDistance =
              distanceDepart + nearestArret.distance + distanceTransfer + walkToDestination;

            if (!bestTransfer || totalDistance < bestTransfer.totalDistance) {
              bestTransfer = {
                arretDescente,
                ligneCorrespondance: autreLigne,
                arretMontee: nearestArret.arret,
                arretDestination: nearestToDest.arret,
                walkDistance: nearestArret.distance + walkToDestination,
                totalDistance,
              };
            }
          }
        }

        if (bestTransfer) {
          const score = 80 - bestTransfer.totalDistance / 1000 - bestTransfer.walkDistance / 100;

          console.log(`       ‚úÖ Correspondance trouv√©e: ${ligneDepart.nom} ‚Üí ${bestTransfer.ligneCorrespondance.nom}`);
          console.log(`          Distance: ${Math.round(bestTransfer.totalDistance)}m (dont ${Math.round(bestTransfer.walkDistance)}m √† pied)`);

          routes.push({
            type: "with_transfer",
            lignes: [ligneDepart, bestTransfer.ligneCorrespondance],
            arrets: [
              depArret,
              bestTransfer.arretDescente,
              bestTransfer.arretMontee,
              bestTransfer.arretDestination,
              destArret,
            ],
            transferCount: 1,
            estimatedDistance: bestTransfer.totalDistance,
            totalDistance: bestTransfer.totalDistance,
            walkingDistance: bestTransfer.walkDistance,
            score,
            instructions: [
              `1. Prendre ${ligneDepart.nom} √† "${depArret.nom}"`,
              `2. Descendre √† "${bestTransfer.arretDescente.nom}"`,
              `3. üö∂ Marcher ${Math.round(
                this.calculateDistance(
                  parseFloat(bestTransfer.arretDescente.latitude),
                  parseFloat(bestTransfer.arretDescente.longitude),
                  parseFloat(bestTransfer.arretMontee.latitude),
                  parseFloat(bestTransfer.arretMontee.longitude)
                )
              )}m jusqu'√† "${bestTransfer.arretMontee.nom}"`,
              `4. Prendre ${bestTransfer.ligneCorrespondance.nom}`,
              `5. Descendre √† "${bestTransfer.arretDestination.nom}"`,
              // `6. üö∂ Marcher ${Math.round(
              //   this.calculateDistance(
              //     parseFloat(bestTransfer.arretDestination.latitude),
              //     parseFloat(bestTransfer.arretDestination.longitude),
              //     parseFloat(destArret.latitude),
              //     parseFloat(destArret.longitude)
              //   )
              // )}m jusqu'√† "${destArret.nom}"`,
              `Distance totale: ${Math.round(bestTransfer.totalDistance)}m`,
              `Distance √† pied: ${Math.round(bestTransfer.walkDistance)}m`,
            ],
          });
        }
      }
    }

    return routes.filter((r) => r.transferCount <= maxTransfers);
  }

  /**
   * Cherche les noms d'arr√™ts qui commencent par les 3 premiers caract√®res de la query.
   * Retourne un tableau de 5 suggestions maximum.
   *
   * @param {string} query La cha√Æne de caract√®res √† chercher.
   * @param {ArretService} arretSvc Le service des arr√™ts.
   * @returns {Promise<string[]>} Un promise qui r√©sout √† un tableau de cha√Ænes de caract√®res.
   */
  private static async getSuggestions(
    query: string,
    arretSvc: ArretService
  ): Promise<string[]> {
    const allArrets = await arretSvc.getAllArrets();
    const suggestions = allArrets
      .filter((a: any) =>
        a.nom.toLowerCase().includes(query.toLowerCase().substring(0, 3))
      )
      .slice(0, 5)
      .map((a: any) => a.nom);

    return suggestions;
  }
}
